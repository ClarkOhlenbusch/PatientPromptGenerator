
Okay, that clarifies the preferred approach. The distinction between handling "empty results" for collections (200 OK) and "resource not found" for specific items (404 Not Found) is sensible.

Regarding your point about performance-critical endpoints: using the wrapper adds minimal overhead (a few extra bytes for the JSON structure). For most typical web API usage, this consistency benefit usually outweighs the very minor performance difference. We can stick with using the wrapper everywhere for now.

**Clarification Needed for Export/Download Endpoints:**

You raised an excellent point about endpoints designed to return files (`/api/patient-prompts/:batchId/export`, `/api/monthly-report`, `/api/download-report/*`). Standard JSON responses don't fit well here.

*   **"No Data Found" Case:**
    *   Returning JSON (`200 OK` with `{ message: "No data..." }`) won't trigger a download and might confuse the user.
    *   Returning `204 No Content` is semantically correct but might not give the user feedback *why* nothing happened.
    *   Attempting to download an empty/minimal file might be technically possible but potentially confusing.
    *   A common pattern is to have the frontend *check* if data exists *before* initiating the download request (e.g., disable the download button if the count is 0). Alternatively, the server could potentially redirect to an informational page if no data exists, but that adds complexity.

*   **Error Handling Case:**
    *   If an error occurs *during* file generation *after* headers have been set, it's difficult to signal this cleanly back to the client as a structured JSON error.
    *   The best approach is usually to buffer the file generation in memory (or a temporary file) and only send the `200 OK` status and file download headers *after* the generation succeeds. If generation fails, you can then send a standard error response (e.g., `500 Internal Server Error` with the JSON wrapper ` { success: false, error: "Failed to generate file" }`). This is more robust.

**Proposal for File Endpoints:**

1.  **Pre-check:** Modify the backend logic. Before attempting file generation, check if the necessary data exists.
2.  **No Data Found:** If no data exists, return `200 OK` with the standard *JSON* wrapper: `{ success: true, data: null, message: "No data available to generate the report/export." }`. The frontend can then interpret this *before* expecting a file and inform the user appropriately (e.g., "No patients found for this period to generate a report.").
3.  **Error During Generation:** Buffer generation. If it fails, return `500 Internal Server Error` with `{ success: false, data: null, error: "Failed to generate file: [details]" }`.
4.  **Success:** If data exists and generation succeeds, send `200 OK` with the appropriate `Content-Type`, `Content-Disposition` headers, and the file data/stream. No JSON wrapper is used here, just the file content.

**Question:** Does this proposed handling for file download/export endpoints sound reasonable?

---

Assuming that approach is acceptable, let's start applying the standard `ApiResponse` structure to a couple of non-file endpoints as planned:

1.  `/api/batches` (GET list - should use 200 OK + empty array if no batches)
2.  `/api/batches/latest` (GET latest - should use 404 + standard error if *no* batches exist at all)

Shall I proceed with refactoring these two endpoints first?
