
Based on your requirements, I'll now outline the implementation changes needed:

```typescript:server/lib/enhancedPdfGenerator.ts
/**
 * Enhanced PDF Generator for Monthly Patient Reports
 * 
 * This module creates comprehensive patient reports with detailed health metrics,
 * visualizations, and insights based on patient data.
 */

import { PatientData, PatientVitals, VitalMeasurement } from '@shared/types';
// New imports needed
// import * as plotly from 'plotly';
// import * as orca from '@plotly/orca';

// Define types for vital signs measurements
export interface VitalStats {
  average: number;
  minimum: number;
  maximum: number;
  stdDev: number;
  alertCount: number;
}

/**
 * Extract real vitals data from patient record
 * @param patientData Patient data from database including rawData
 * @param days Number of days to include in the report
 */
export function extractPatientVitals(patientData: any, days = 30): PatientVitals {
  // Initialize empty vitals structure
  const vitals = {
    heartRate: [] as VitalMeasurement[],
    oxygenSaturation: [] as VitalMeasurement[],
    glucose: [] as VitalMeasurement[]
  };
  
  // Early return if no raw data available
  if (!patientData.rawData || !patientData.rawData.variables) {
    // Fall back to sample data for backward compatibility
    console.warn('No raw vital data found, using sample data');
    return generateSampleVitals(patientData, days);
  }
  
  try {
    // Extract variables from raw data
    const variables = patientData.rawData.variables;
    
    // Process each variable type if available
    if (variables.heartRate) {
      vitals.heartRate = mapRawDataToVitalMeasurements(variables.heartRate, days);
    }
    
    if (variables.oxygenSaturation) {
      vitals.oxygenSaturation = mapRawDataToVitalMeasurements(variables.oxygenSaturation, days);
    }
    
    if (variables.glucose) {
      vitals.glucose = mapRawDataToVitalMeasurements(variables.glucose, days);
    }
    
    return vitals;
  } catch (error) {
    console.error('Error extracting patient vitals:', error);
    // Fall back to sample data if extraction fails
    return generateSampleVitals(patientData, days);
  }
}

/**
 * Map raw data from database to VitalMeasurement format
 * @param rawMeasurements Array of raw measurements from database
 * @param days Number of days to include
 */
function mapRawDataToVitalMeasurements(rawMeasurements: any[], days: number): VitalMeasurement[] {
  const today = new Date();
  const cutoffDate = new Date(today);
  cutoffDate.setDate(today.getDate() - days);
  
  return rawMeasurements
    .filter(measurement => {
      const measurementDate = new Date(measurement.date);
      return measurementDate >= cutoffDate && measurementDate <= today;
    })
    .map(measurement => ({
      date: new Date(measurement.date),
      value: measurement.value,
      isAlert: measurement.isAlert || false
    }))
    .sort((a, b) => a.date.getTime() - b.date.getTime());
}

/**
 * Determine which vital signs are in alert state
 * @param patientData Patient data including alert information
 * @param vitals The vital measurements
 */
function determineAlertedVitals(patientData: any, vitals: PatientVitals): string[] {
  const alertedVitals: string[] = [];
  
  // Check if patient has global alert
  if (patientData.isAlert === 'true' || patientData.isAlert === true) {
    // Check specific alert reasons if available
    if (patientData.alertReasons && Array.isArray(patientData.alertReasons)) {
      return patientData.alertReasons;
    }
    
    // Otherwise check each vital for alerts
    if (vitals.heartRate.some(reading => reading.isAlert)) {
      alertedVitals.push('heartRate');
    }
    
    if (vitals.oxygenSaturation.some(reading => reading.isAlert)) {
      alertedVitals.push('oxygenSaturation');
    }
    
    if (vitals.glucose.some(reading => reading.isAlert)) {
      alertedVitals.push('glucose');
    }
  }
  
  return alertedVitals;
}

/**
 * Generate Plotly chart for vital measurements and convert to base64 image
 * @param readings Vital measurements
 * @param title Chart title
 * @param unit Unit of measurement
 * @param thresholds Alert thresholds
 */
export async function generatePlotlyChartImage(
  readings: VitalMeasurement[],
  title: string,
  unit: string,
  thresholds: { high?: number, low?: number } = {}
): Promise<string> {
  // Skip if no readings
  if (!readings || readings.length === 0) {
    return '';
  }
  
  // Extract data for plotting
  const dates = readings.map(r => r.date);
  const values = readings.map(r => r.value);
  const alerts = readings.filter(r => r.isAlert);
  
  // Create traces
  const traces = [
    {
      x: dates,
      y: values,
      mode: 'lines+markers',
      name: title,
      line: {
        color: '#3498db',
        width: 2
      },
      marker: {
        size: 6,
        color: '#3498db'
      }
    }
  ];
  
  // Add alert points if any
  if (alerts.length > 0) {
    traces.push({
      x: alerts.map(a => a.date),
      y: alerts.map(a => a.value),
      mode: 'markers',
      name: 'Alerts',
      marker: {
        symbol: 'x',
        size: 10,
        color: '#e74c3c'
      }
    });
  }
  
  // Add threshold lines if specified
  if (thresholds.high) {
    traces.push({
      x: [dates[0], dates[dates.length - 1]],
      y: [thresholds.high, thresholds.high],
      mode: 'lines',
      name: 'Upper Threshold',
      line: {
        color: '#e74c3c',
        width: 1,
        dash: 'dash'
      }
    });
  }
  
  if (thresholds.low) {
    traces.push({
      x: [dates[0], dates[dates.length - 1]],
      y: [thresholds.low, thresholds.low],
      mode: 'lines',
      name: 'Lower Threshold',
      line: {
        color: '#e74c3c',
        width: 1,
        dash: 'dash'
      }
    });
  }
  
  // Layout configuration
  const layout = {
    title: `${title} (${unit})`,
    xaxis: {
      title: 'Measurement Date'
    },
    yaxis: {
      title: `${title} (${unit})`
    },
    width: 500,
    height: 200,
    margin: {
      l: 50,
      r: 50,
      b: 50,
      t: 50,
      pad: 4
    }
  };
  
  // This would be the actual implementation with Plotly
  // Currently commented out as we need to install the dependencies
  /*
  const figure = { data: traces, layout };
  const imgOpts = {
    format: 'png',
    width: 500,
    height: 200
  };
  
  // Generate the image 
  const imgBuffer = await plotly.toImage(figure, imgOpts);
  return imgBuffer.toString('base64');
  */
  
  // Placeholder return until Plotly is integrated
  console.log('Plotly chart would be generated with:', { traces, layout });
  return 'base64_image_placeholder';
}

// Keeping the existing function for backward compatibility
export function generatePatientReportDefinition(patientData: any, patientVitals: PatientVitals) {
  // Use real data instead of sample data
  const actualVitals = patientData.rawData ? 
    extractPatientVitals(patientData) : patientVitals;
  
  // Determine which vitals are alerting
  const alertedVitals = determineAlertedVitals(patientData, actualVitals);
  
  // Calculate stats for each vital
  const heartRateStats = calculateStats(actualVitals.heartRate);
  const oxygenStats = calculateStats(actualVitals.oxygenSaturation);
  const glucoseStats = calculateStats(actualVitals.glucose);
  
  // Format dates for the report
  const reportStartDate = actualVitals.heartRate.length > 0 ? 
    actualVitals.heartRate[0].date : new Date();
  const reportEndDate = actualVitals.heartRate.length > 0 ? 
    actualVitals.heartRate[actualVitals.heartRate.length - 1].date : new Date();
  const dateRange = `${reportStartDate.toLocaleDateString()} - ${reportEndDate.toLocaleDateString()}`;
  
  // Generate content sections based on alerted vitals
  const contentSections = [];
  
  // Here we would add code to generate plotly charts for the alerted vitals
  // and add them to the content sections
  
  // Header section would remain unchanged
  
  // The rest of the function would be similar to the original but only include
  // sections for alerted vitals instead of all vitals
  
  // Rest of original implementation...
}
```

Before implementing this fully, I need more information:

1. What is the exact structure of the `rawData.variables` field in the patient records?
2. Do we need to completely remove the previous chart generation methods or maintain them as fallbacks?
3. Would you prefer to install the plotly packages first or should I provide the complete implementation assuming they will be installed later?
